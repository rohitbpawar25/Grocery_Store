#include <iostream> 
#include <list> 
#include <map> 
#include <queue> 
using namespace std; 
template <typename T> 
class Graph { 
    map<T, list<T>> adjList; 
public: 
    void addEdge(T src, T dest) { 
        adjList[src].push_back(dest); 
        adjList[dest].push_back(src); 
    } 
    void bfs(queue<T> &q, map<T, bool> &visited) { 
        if (q.empty()) return; 
        T node = q.front(); 
        q.pop(); 
        cout << node << " "; 
        for (T n : adjList[node]) { 
            if (!visited[n]) { 
                q.push(n); 
                visited[n] = true; 
            } 
        } 
        bfs(q, visited); 
    } 
    void dfs(T v, map<T, bool> &visited) { 
        visited[v] = true; 
        cout << v << " "; 
 
        for (T n : adjList[v]) { 
            if (!visited[n]) { 
                dfs(n, visited); 
            } 
        } 
    } 
}; 
int main() { 
    Graph<int> g; 
    g.addEdge(0, 1); 
    g.addEdge(0, 2); 
    g.addEdge(0, 3); 
    g.addEdge(1, 4); 
    g.addEdge(2, 5); 
    g.addEdge(3, 6); 
    g.addEdge(3, 7); 
    queue<int> q; 
    map<int, bool> visited; 
    int ch; 
    cout << "Enter 1 for BFS & 2 for DFS: "; 
    cin >> ch; 
    for (int i = 0; i < 8; i++) { 
        visited[i] = false; 
    } 
    if (ch == 1) { 
        // BFS traversal 
        for (int i = 0; i < 8; i++) { 
            if (!visited[i]) { 
                visited[i] = true; 
                q.push(i); 
                g.bfs(q, visited); 
            } 
        } 
        cout << endl; 
    } else { 
        for (int i = 0; i < 8; i++) { 
            if (!visited[i]) { 
                g.dfs(i, visited); 
            } 
        } 
        cout << endl; 
    } 
    return 0; 
} 
